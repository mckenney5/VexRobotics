#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  p1,             sensorTouch)
#pragma config(Sensor, dgtl2,  p2,             sensorTouch)
#pragma config(Sensor, dgtl3,  p3,             sensorTouch)
#pragma config(Sensor, dgtl12, rackbtn,        sensorTouch)
#pragma config(Sensor, I2C_1,  encoder_bleft,  sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  encoder_aleft,  sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  encoder_fleft,  sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  encoder_fright, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  encoder_bright, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  encoder_rack,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_7,  encoder_aright, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_8,  encoder_spool,  sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           t269,          tmotorVex269, openLoop)
#pragma config(Motor,  port2,           bleft,         tmotorVex393, PIDControl, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port3,           aleft,         tmotorVex393, PIDControl, reversed, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port4,           fleft,         tmotorVex269, PIDControl, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port5,           fright,        tmotorVex269, PIDControl, reversed, encoder, encoderPort, I2C_4, 1000)
#pragma config(Motor,  port6,           bright,        tmotorVex393, PIDControl, reversed, encoder, encoderPort, I2C_5, 1000)
#pragma config(Motor,  port7,           rack,          tmotorVex269, PIDControl, reversed, encoder, encoderPort, I2C_6, 1000)
#pragma config(Motor,  port8,           aright,        tmotorVex393, PIDControl, encoder, encoderPort, I2C_7, 1000)
#pragma config(Motor,  port9,           spool,         tmotorVex393, PIDControl, encoder, encoderPort, I2C_8, 1000)
#pragma config(Motor,  port10,          t393,          tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////
#pragma platform(VEX)										//
#pragma competitionControl(Competition) //
#pragma autonomousDuration(20)					//	<--------Main Competition Code
#pragma userControlDuration(120)				//						 !!DO NOT MODIFY!!
#include "Vex_Competition_Includes.c" 	//
//////////////////////////////////////////

bool check = true; //--------------------------------Jumper Variable
int ebleft = nMotorEncoder[bleft]; //----------------Back Left Encoder Variable
int vbleft = 0; //-----------------------------------Back Left Brake Variable
int ebright = nMotorEncoder[bright]; //--------------Back Right Encoder Variable
int vbright = 0; //----------------------------------Back Right Brake Variable
int efleft = nMotorEncoder[fleft]; //----------------Front Left Encoder Variable
int vfleft = 0; //-----------------------------------Front Left Brake Variable
int efright = nMotorEncoder[fright]; //--------------Front Right Encoder Variable
int vfright = 0; //----------------------------------Front Right Brake Variable
int ealeft = nMotorEncoder[aleft]; //----------------Left Arm Encoder Variable
int valeft = 0; //-----------------------------------Left Arm Brake Variable
int earight = nMotorEncoder[aright]; //--------------Right Arm Encoder Variable
int varight = 0; //----------------------------------Right Arm Brake Variable
int erack = nMotorEncoder[rack]; //------------------Rack Encoder Variable
int vrack = 0; //------------------------------------Rack Brake Variable

void pre_auton()
{
  bStopTasksBetweenModes = true; //------------------Set bStopTasksBetweenModes to false to keep user created tasks running
  																									 //between Autonomous and Tele-Op modes. Will need to manage all user
  																									 //created tasks if set to false.
  nMotorEncoder[bleft] = 0; //-----------------------Reset Back Left Motor Encoder
  nMotorEncoder[bright] = 0; //----------------------Reset Back Right Motor Encoder
  nMotorEncoder[fleft] = 0; //-----------------------Reset Front Left Motor Encoder
  nMotorEncoder[fright] = 0; //----------------------Reset Front Right Motor Encoder

  //-------------------------------------------------#Check Jumper Position#
  if (SensorValue(p1)==1 || SensorValue(p2)==1 || SensorValue(p3)==1)
  	check = true; //------------------------------------Check Ports 1,2,3
 	else //-----------------------------------------------Default
 		check = false;
 	//-------------------------------------------------##End Jumper Position##
}
task bleftbrake()
{
	while(true)
	{
		motor[bleft] = vbleft - ebleft;
	}
}
task autonomous()
{
	p0:
	switch (check)
	{
		case false:
		//-----------------------------------------------*Default Program*

		//-----------------------------------------------**End Default Program**
		break;
		default:
			if (SensorValue(p1)==1)
			{
				while(SensorValue(p1)==1)
				{
					clearLCDLine(0);
  				clearLCDLine(1);
  				displayLCDCenteredString(1,"Program 1");
  			}
			}
  		else if (SensorValue(p2)==1)
  		{
  			clearLCDLine(0);
  			displayLCDCenteredString(0,"Autonomous");
  			clearLCDLine(1);
  			displayLCDCenteredString(1,"Program 2");
				vbleft = 100;
				StartTask(bleftbrake);
				while(SensorValue(p2)==1)
				{}
				StopTask(bleftbrake);
  		}
 			else if (SensorValue(p3)==1)
 			{
				clearLCDLine(0);
  			displayLCDCenteredString(0,"Autonomous");
  			clearLCDLine(1);
  			displayLCDCenteredString(1,"Program 3");
  			vbleft = 100;
  			motor[bleft] = vbleft - ebleft;
  			while(SensorValue(p3)==1)
  			{}
 			}
 			else
 			{
 				check = false;
				goto p0;
 			}
		break;
	}
	check = true; //-----------------------------------Jumper Check Enabled
//AutonomousCodePlaceholderForTesting(); //----------Interface With Debugger
}

task usercontrol()
{
	const int ths = 15; //-----------------------------Threshold Variable
	int c1 = 0, c2 = 0, c3 = 0, c4 = 0;	//-------------Deadzone Variables
	while(true) //-------------------------------------Infinite Loop
	{
	//-------------------------------------------------#Calculate Deadzones#
		if(abs(vexRT[Ch1]) > ths) //------------------------1 Axis
			c1 = vexRT[Ch1];
		else
			c1 = 0;
		if(abs(vexRT[Ch2]) > ths) //------------------------2 Axis
			c2 = vexRT[Ch2];
		else
			c2 = 0;
		if(abs(vexRT[Ch3]) > ths) //------------------------3 Axis
			c3 = vexRT[Ch3];
		else
			c3 = 0;
		if(abs(vexRT[Ch4]) > ths) //------------------------4 Axis
			c4 = vexRT[Ch4];
		else
			c4 = 0;
	//-------------------------------------------------##End Deadzones##

	//UserControlCodePlaceholderForTesting(); //-------Interface With Debugger

	//-------------------------------------------------*Controller Assignments*
		if(vexRT[Btn5U]==1)
		{
			motor[fleft] = -100;
			motor[fright] = 100;
		}
		else if(vexRT[Btn6U]==1)
		{
			motor[fleft] = 100;
			motor[fright] = -100;
		}
		else if(vexRT[Btn5D]==1)
		{
			motor[bleft] = -100;
			motor[bright] = 100;
		}
		else if(vexRT[Btn6D]==1)
		{
			motor[bleft] = 100;
			motor[bright] = -100;
		}
		else
		{
			motor[bleft] = c3 + c4; //------------------------Back Left Wheel
			motor[bright] = c3 - c4; //-----------------------Back Right Wheel
			motor[fleft] = c3 + c4; //------------------------Front Left Wheel
			motor[fright] = c3 - c4; //-----------------------Front Right Wheel
		}
		if(SensorValue(rackbtn)==1 && c1 > 0) //----------Rack Safety Button
			motor[rack] = 0;
		else
			motor[rack] = c1; //----------------------------Rack Motor

		motor[aleft] = c2/2; //-------------------------------Left Arm Motor
		motor[aright] = c2/2; //------------------------------Right Arm Motor

		if(vexRT[Btn8D]==1)
			motor[t393] = 127;
		else if(vexRT[Btn8R]==1)
			motor[t269] = 127;
		else
		{
			motor[t269] = 0;
			motor[t393] = 0;
		}
		if(vexRT[Btn7D]==1)
			motor[spool] = 127;
		else if(vexRT[Btn7L]==1)
			motor[spool] = -127;
		else
			motor[spool] = 0;
	//-------------------------------------------------**End Assignments**
	}
}
