#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  override,       sensorTouch)
#pragma config(Sensor, I2C_1,  encoder_rdrive, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  encoder_rarm,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  encoder_larm,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  encoder_ldrive, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  encoder_lbucket, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  encoder_rbucket, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           t269,          tmotorVex269_HBridge, openLoop)
#pragma config(Motor,  port2,           LDrive,        tmotorVex393_MC29, PIDControl, encoderPort, I2C_1)
#pragma config(Motor,  port3,           RDrive,        tmotorVex393_MC29, PIDControl, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           LArm,          tmotorVex393_MC29, PIDControl, encoderPort, I2C_3)
#pragma config(Motor,  port5,           RArm,          tmotorVex393_MC29, PIDControl, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port6,           LBucket,       tmotorVex393_MC29, PIDControl, encoderPort, I2C_5)
#pragma config(Motor,  port7,           RBucket,       tmotorVex393_MC29, PIDControl, reversed, encoderPort, I2C_6)
#pragma config(Motor,  port8,           LPaddle,       tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port9,           RPaddle,       tmotorVex269_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          t393,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard!!*//

//////////////////////////////////////////
#pragma platform(VEX)										//
#pragma competitionControl(Competition) //
#pragma autonomousDuration(20)					//	<--------Main Competition Code
#pragma userControlDuration(120)				//						 !!DO NOT MODIFY!!
#include "Vex_Competition_Includes.c" 	//
//////////////////////////////////////////

short aselect = 0; 																	//Autonomous Switch Variable
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;
string mainBattery, backupBattery;
void pre_auton()
{
  bStopTasksBetweenModes = true; 										//Set bStopTasksBetweenModes to false to keep user created tasks running
  																									//between Autonomous and Tele-Op modes. Will need to manage all user
																										//created tasks if set to false.
  nMotorEncoder[RDrive] = 0;
  nMotorEncoder[RArm] = 0;
  nMotorEncoder[LArm] = 0;
  nMotorEncoder[LDrive] = 0;
  nMotorEncoder[LBucket] = 0;
  nMotorEncoder[LBucket] = 0;

																										//$Autonomous Program Selection$
  bLCDBacklight = true;
  clearLCDLine(0);
  clearLCDLine(1);
  displayLCDString(0, 0, "Primary: ");
	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V');
	displayNextLCDString(mainBattery);
	displayLCDString(1, 0, "Backup: ");
	sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');
	displayNextLCDString(backupBattery);
	sleep(2000);

	clearLCDLine(0);
  clearLCDLine(1);
	displayLCDPos(0,0);
	displayNextLCDString("Autonomous ");
	displayLCDPos(0,11);
	displayNextLCDNumber(aselect);
	displayLCDCenteredString(1,"<      X     >");
	while(nLCDButtons!=centerButton)
	{
		if(nLCDButtons==rightButton)
		{
			aselect++;
			clearLCDLine(0);
			displayLCDPos(0,0);
			displayNextLCDString("Autonomous ");
			displayLCDPos(0,11);
			displayNextLCDNumber(aselect);
			while(nLCDButtons==rightButton){}
		}
		else if(nLCDButtons==leftButton)
		{
			clearLCDLine(0);
			displayLCDPos(0,0);
			displayNextLCDString("Autonomous ");
			aselect--;
			displayLCDPos(0,11);
			displayNextLCDNumber(aselect);
			while(nLCDButtons==leftButton){}
		}
	}
	clearLCDLine(1);
	displayLCDCenteredString(1,"Selected");
	sleep(2000);
	bLCDBacklight = false;
}
																											//$$End Autonomous Selection$$
task autonomous()
{
	reset:
	switch(aselect)
	{
		case 0:
			clearLCDLine(0);
			displayLCDCenteredString(0,"pgm0 WORKING");
		break;

		case 1:
			clearLCDLine(1);
			displayLCDCenteredString(1,"pgm1 WORKING");
		break;

		default:
			aselect = 0;
			goto reset;
		break;
	}
//AutonomousCodePlaceholderForTesting(); 							//Interface With Debugger
}

task usercontrol()
{
	const short ths = 15; 															//Threshold Variable
	short c1 = 0, c2 = 0, c3 = 0, c4 = 0;								//Deadzone Variables
	while(true) 																				//Infinite Loop
	{
																											//$Calculate Deadzones$
		if(abs(vexRT[Ch1]) > ths) 												//1 Axis
			c1 = vexRT[Ch1];
		else
			c1 = 0;
		if(abs(vexRT[Ch2]) > ths) 												//2 Axis
			c2 = vexRT[Ch2];
		else
			c2 = 0;
		if(abs(vexRT[Ch3]) > ths) 												//3 Axis
			c3 = vexRT[Ch3];
		else
			c3 = 0;
		if(abs(vexRT[Ch4]) > ths) 												//4 Axis
			c4 = vexRT[Ch4];
		else
			c4 = 0;
																											//$$End Deadzones$$

	//UserControlCodePlaceholderForTesting(); 					//Interface With Debugger

																											//$Controller Assignments$
			//Drive
			if (vexRT[Ch3] != 0 && abs(vexRT[Ch4] < 70)){ 	//If the left thumb stick is pushed up and not even close to left or right
			motor[LDrive] = vexRT[Ch3];
			motor[RDrive] = vexRT[Ch3];
		}
			if (vexRT[Ch4] != 0){
				if (vexRT[Ch4] == 100){
					motor[LDrive] = -50;
					motor[RDrive] = 50;
			}
				else if (vexRT[Ch4] == -100){
					motor[LDrive] = 50;
					motor[RDrive] = -50;
				}
		}
			if (vexRT[Ch2] != 0){
				motor[LBucket] = vexRT[Ch2];
				motor[RBucket] = vexRT[Ch2];
		}

																											//$$End Assignments$$

	} //Infinite loop
}		//End of driver control
