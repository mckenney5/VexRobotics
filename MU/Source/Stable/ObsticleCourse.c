#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl3,  TouchSensor,    sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           LeftForwardMotorA, tmotorVex393_HBridge, openLoop, reversed, driveLeft, encoderPort, None)
#pragma config(Motor,  port2,           LeftMiddleMotorA, tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, None)
#pragma config(Motor,  port3,           LeftRearMotorA, tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port4,           LeftForwardMotorD, tmotorVex393_MC29, openLoop, driveLeft, encoderPort, None)
#pragma config(Motor,  port5,           LeftRearMotorD, tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port6,           RightForwardMotorD, tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, None)
#pragma config(Motor,  port7,           RightRearMotorD, tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port8,           RightForwardMotorA, tmotorVex393_MC29, openLoop, driveRight, encoderPort, None)
#pragma config(Motor,  port9,           RightMiddleMotorA, tmotorVex393_MC29, openLoop, driveRight, encoderPort, None)
#pragma config(Motor,  port10,          RightRearMotorA, tmotorVex393_HBridge, openLoop, driveRight, encoderPort, None)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
const int POWAH = 60;
const int TURN = 650;
const int WAIT = 2000;
//6 inches per 100 tics on 60 power
//500 TICS for 90o turns on 60 power
task main(){
	//wait1Msec(WAIT); //add const for wait between steps
	while(vexRT[Btn8D] == 0){ //<------------ testing
		wait1Msec(100);
	}
	int TargetDistance = 0; //in inches, take TargetDistance / 6 then multiply by 100
	int TicsNeeded = 0;
	//--1 //face forward
	//400 tics
	TicsNeeded = 400;
	nMotorEncoder[LeftRearMotorD] = 0;
	motor[LeftRearMotorD] = POWAH;
	motor[LeftForwardMotorD] = POWAH;
	motor[RightForwardMotorD] = POWAH;
	motor[RightRearMotorD] = POWAH;
	while(nMotorEncoder[LeftRearMotorD] <= TicsNeeded){
				//foo
	}
	motor[LeftRearMotorD] = 0;
	motor[RightRearMotorD] = 0;
	motor[LeftForwardMotorD] = 0;
	motor[RightForwardMotorD] = 0;
	TicsNeeded = 0;
	wait1Msec(WAIT);
	//--2 //90o Left Turn (left side negative)
	//-500 tics
	TicsNeeded = -TURN;
	nMotorEncoder[LeftRearMotorD] = 0;
	motor[LeftRearMotorD] = -POWAH;
	motor[LeftForwardMotorD] = -POWAH;
	motor[RightForwardMotorD] = POWAH;
	motor[RightRearMotorD] = POWAH;
	while(nMotorEncoder[LeftRearMotorD] >= TicsNeeded){
				//foo
	}
	motor[LeftRearMotorD] = 0;
	motor[RightRearMotorD] = 0;
	motor[LeftForwardMotorD] = 0;
	motor[RightForwardMotorD] = 0;
	TicsNeeded = 0;
	wait1Msec(WAIT);
	//--3 //50" foreward
	//500 tics
	TicsNeeded = 833.3;
	nMotorEncoder[LeftRearMotorD] = 0;
	motor[LeftRearMotorD] = POWAH;
	motor[LeftForwardMotorD] = POWAH;
	motor[RightForwardMotorD] = POWAH;
	motor[RightRearMotorD] = POWAH;
	while(nMotorEncoder[LeftRearMotorD] <= TicsNeeded){
				//foo
	}
	motor[LeftRearMotorD] = 0;
	motor[RightRearMotorD] = 0;
	motor[LeftForwardMotorD] = 0;
	motor[RightForwardMotorD] = 0;
	TicsNeeded = 0;
	wait1Msec(WAIT);
	//--4 //90o Right Turn (right is negative)
	//500 tics
	TicsNeeded = TURN;
	nMotorEncoder[LeftRearMotorD] = 0;
	motor[LeftRearMotorD] = POWAH;
	motor[LeftForwardMotorD] = POWAH;
	motor[RightForwardMotorD] = -POWAH;
	motor[RightRearMotorD] = -POWAH;
	while(nMotorEncoder[LeftRearMotorD] <= TicsNeeded){
				//foo
	}
	motor[LeftRearMotorD] = 0;
	motor[RightRearMotorD] = 0;
	motor[LeftForwardMotorD] = 0;
	motor[RightForwardMotorD] = 0;
	TicsNeeded = 0;
	wait1Msec(WAIT);
	//--5 //160" foreward //plus 3ft //plus 2ft //plus 18"
	//2667 tics
	TicsNeeded = 3967;
	nMotorEncoder[LeftRearMotorD] = 0;
	motor[LeftRearMotorD] = POWAH;
	motor[LeftForwardMotorD] = POWAH;
	motor[RightForwardMotorD] = POWAH;
	motor[RightRearMotorD] = POWAH;
	while(nMotorEncoder[LeftRearMotorD] <= TicsNeeded){
				//foo
	}
	motor[LeftRearMotorD] = 0;
	motor[RightRearMotorD] = 0;
	motor[LeftForwardMotorD] = 0;
	motor[RightForwardMotorD] = 0;
	TicsNeeded = 0;
	wait1Msec(WAIT);
	//--6 //90o Right Turn (left neg)
	//-500 tics
	TicsNeeded = -TURN;
	nMotorEncoder[LeftRearMotorD] = 0;
	motor[LeftRearMotorD] = -POWAH;
	motor[LeftForwardMotorD] = -POWAH;
	motor[RightForwardMotorD] = POWAH;
	motor[RightRearMotorD] = POWAH;
	while(nMotorEncoder[LeftRearMotorD] >= TicsNeeded){
				//foo
	}
	motor[LeftRearMotorD] = 0;
	motor[RightRearMotorD] = 0;
	motor[LeftForwardMotorD] = 0;
	motor[RightForwardMotorD] = 0;
	TicsNeeded = 0;
	wait1Msec(WAIT);
	//--7 //24" foreward
	//500 tics
	TicsNeeded = 500;
	nMotorEncoder[LeftRearMotorD] = 0;
	motor[LeftRearMotorD] = POWAH;
	motor[LeftForwardMotorD] = POWAH;
	motor[RightForwardMotorD] = POWAH;
	motor[RightRearMotorD] = POWAH;
	while(nMotorEncoder[LeftRearMotorD] <= TicsNeeded){
				//foo
	}
	motor[LeftRearMotorD] = 0;
	motor[RightRearMotorD] = 0;
	motor[LeftForwardMotorD] = 0;
	motor[RightForwardMotorD] = 0;
	TicsNeeded = 0;
	wait1Msec(WAIT);
		//--8 45o right turn (right neg)
	//400 tics
	TicsNeeded = TURN/4;
	nMotorEncoder[LeftRearMotorD] = 0;
	motor[LeftRearMotorD] = POWAH;
	motor[LeftForwardMotorD] = POWAH;
	motor[RightForwardMotorD] = -POWAH;
	motor[RightRearMotorD] = -POWAH;
	while(nMotorEncoder[LeftRearMotorD] <= TicsNeeded){
				//foo
	}
	motor[LeftRearMotorD] = 0;
	motor[RightRearMotorD] = 0;
	motor[LeftForwardMotorD] = 0;
	motor[RightForwardMotorD] = 0;
	TicsNeeded = 0;
	wait1Msec(WAIT);
	//--9 lift arm
	//lift arm
	//Arm
	const unsigned int POWAH2 = 50; //60
	motor[RightForwardMotorA] = POWAH2;
	motor[RightRearMotorA] = POWAH2;
	motor[RightMiddleMotorA] = POWAH2;
	motor[LeftForwardMotorA] = POWAH2;
	motor[LeftMiddleMotorA] = POWAH2;
	motor[LeftForwardMotorA] = POWAH2;
	wait1Msec(3000); // <----------------------
	//All motors stop
	motor[LeftRearMotorA] = 0;
	motor[LeftForwardMotorA] = 0;
	motor[LeftMiddleMotorA] = 0;
	motor[RightForwardMotorA] = 0;
	motor[RightMiddleMotorA] = 0;
	motor[RightRearMotorA] = 0;
	//charge
	//--10
	motor[LeftRearMotorD] = POWAH;
	motor[LeftForwardMotorD] = POWAH;
	motor[RightForwardMotorD] = POWAH;
	motor[RightRearMotorD] = POWAH;
	wait1Msec(6000);
	motor[LeftRearMotorD] = 0;
	motor[RightRearMotorD] = 0;
	motor[LeftForwardMotorD] = 0;
	motor[RightForwardMotorD] = 0;
}
