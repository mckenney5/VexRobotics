#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  encoder_LeftRearMotorD,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  encoder_LeftRearMotorA,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           LeftForwardMotorA, tmotorVex393_HBridge, openLoop, reversed, driveLeft, encoderPort, None)
#pragma config(Motor,  port2,           LeftMiddleMotorA, tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, None)
#pragma config(Motor,  port3,           LeftRearMotorA, tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port4,           LeftForwardMotorD, tmotorVex393_MC29, openLoop, driveLeft, encoderPort, None)
#pragma config(Motor,  port5,           LeftRearMotorD, tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port6,           RightForwardMotorD, tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, None)
#pragma config(Motor,  port7,           RightRearMotorD, tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port8,           RightForwardMotorA, tmotorVex393_MC29, openLoop, driveRight, encoderPort, None)
#pragma config(Motor,  port9,           RightMiddleMotorA, tmotorVex393_MC29, openLoop, driveRight, encoderPort, None)
#pragma config(Motor,  port10,          RightRearMotorA, tmotorVex393_HBridge, openLoop, driveRight, encoderPort, None)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
/*!!Code automatically generated by 'ROBOTC' configuration wizard               !!
VEX Robotics Source Code, See License (../../LICENSE.TXT)*/

task main(){
	wait1Msec(1000);
	nMotorEncoder[LeftRearMotorD] = 0;
	moveMotorTarget(LeftRearMotorD, 1000, 100);
	//Slave Mapping
		//LeftRearMotorD is Master for LDriver
		//RightRearMotorD is master for RDriver
		//motor[RightForwardMotorD] = motor[RightRearMotorD];
		//motor[LeftForwardMotorD] = motor[LeftRearMotorD];
	motor[RightForwardMotorD] = motor[LeftRearMotorD];
	motor[RightRearMotorD] = motor[LeftRearMotorD];
	motor[LeftForwardMotorD] = motor[LeftRearMotorD];
	waitUntilMotorStop(LeftRearMotorD);
//All Motors Off
	motor[LeftRearMotorD] = 0;
	motor[RightRearMotorD] = 0;
	motor[LeftRearMotorA] = 0;
//Drive
	motor[LeftForwardMotorD] = 0;
	motor[RightForwardMotorD] = 0;
//Arm
	motor[LeftForwardMotorA] = 0;
	motor[LeftMiddleMotorA] = 0;
	motor[RightForwardMotorA] = 0;
	motor[RightMiddleMotorA] = 0;
	motor[RightRearMotorA] = 0;


	/*	//LeftRearMotorA is Master for Arm
		motor[RightForwardMotorA] = motor[LeftRearMotorA];
		motor[RightRearMotorA] = motor[LeftRearMotorA];
		motor[RightMiddleMotorA] = motor[LeftRearMotorA];
		motor[LeftForwardMotorA] = motor[LeftRearMotorA];
		motor[LeftMiddleMotorA] = motor[LeftRearMotorA];
	//End Slave*/
}
