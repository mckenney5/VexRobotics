#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           LeftForwardMotorA, tmotorVex393_HBridge, openLoop, reversed, driveLeft, encoderPort, None)
#pragma config(Motor,  port2,           LeftMiddleMotorA, tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, None)
#pragma config(Motor,  port3,           LeftRearMotorA, tmotorVex393_MC29, PIDControl, reversed, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port4,           LeftForwardMotorD, tmotorVex393_MC29, openLoop, driveLeft, encoderPort, None)
#pragma config(Motor,  port5,           LeftRearMotorD, tmotorVex393_MC29, openLoop, driveLeft, encoderPort, None)
#pragma config(Motor,  port6,           RightForwardMotorD, tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, None)
#pragma config(Motor,  port7,           RightRearMotorD, tmotorVex393_MC29, PIDControl, reversed, driveRight, encoderPort, I2C_1)
#pragma config(Motor,  port8,           RightForwardMotorA, tmotorVex393_MC29, openLoop, driveRight, encoderPort, None)
#pragma config(Motor,  port9,           RightMiddleMotorA, tmotorVex393_MC29, openLoop, driveRight, encoderPort, None)
#pragma config(Motor,  port10,          RightRearMotorA, tmotorVex393_HBridge, openLoop, driveRight, encoderPort, None)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
VEX Robotics Source Code
See License (../../LICENSE.TXT)
*/

const int THRESHOLD = 15; //Threshold Variable
int c2X = 0, c2 = 0, c3 = 0;	//Deadzone Variables

task main()
{
	while(true){
	//All Motor Stop
		//Masters
		if (vexRT[Btn8D] == 1){
			motor[LeftRearMotorD] = 0;
			motor[RightRearMotorD] = 0;
			motor[LeftRearMotorA] = 0;
		//Drive
			motor[LeftForwardMotorD] = 0;
			motor[RightForwardMotorD] = 0;
		//Arm
			motor[LeftForwardMotorA] = 0;
			motor[LeftMiddleMotorA] = 0;
			motor[RightForwardMotorA] = 0;
			motor[RightMiddleMotorA] = 0;
			motor[RightRearMotorA] = 0;
			//wait1Msec(5000); //wait 5 sec
		}

	//Slave Mapping
		//LeftRearMotorD is Master for LDriver
		//RightRearMotorD is master for RDriver
		motor[RightForwardMotorD] = motor[RightRearMotorD];
		motor[LeftForwardMotorD] = motor[LeftRearMotorD];

		//LeftRearMotorA is Master for Arm
		motor[RightForwardMotorA] = motor[LeftRearMotorA];
		motor[RightRearMotorA] = motor[LeftRearMotorA];
		motor[RightMiddleMotorA] = motor[LeftRearMotorA];
		motor[LeftForwardMotorA] = motor[LeftRearMotorA];
		motor[LeftMiddleMotorA] = motor[LeftRearMotorA];
	//End Slave

	//User Input
		//Driver
		if(abs(vexRT[Ch2]) > THRESHOLD) //2 Axis
			c2 = vexRT[Ch2];
		else
			c2 = 0;
		if(abs(vexRT[Ch3]) > THRESHOLD) //3 Axis
			c3 = vexRT[Ch3];
		else
			c3 = 0;
		motor[LeftRearMotorD] = c3;
		motor[RightRearMotorD] = c2;

		//Arm
		if(abs(vexRT[Ch2Xmtr2]) > THRESHOLD) //2X Axis
			c2X = vexRT[Ch2Xmtr2];
		else
			c2X = 0;
		//Arm Govenor
		int gov = (c2X / 2) -15;
		motor[LeftRearMotorA] = gov;
	}
}
